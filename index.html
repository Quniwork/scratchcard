<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/style2.css">
</head>

<body>
  <div id="app">
    <div class="float">
      <img src="image/float01.png" class="float01">
      <img src="image/float02.png" class="float02">
    </div>
    <header>
      <div class="header-left">
        <div class="header-number">
          <span class="year">2024</span>
          <span class="period">ç¬¬4æœŸ</span>
        </div>
        <ul class="scratch-rule">
          <li>æ­¤æ´»å‹•ç‚ºé¡å¤–åŠ ç¢¼ï¼Œéæ©Ÿå°å…§è²©å”®å•†å“</li>
          <li>ç¬¦åˆè³‡æ ¼å¯è‡ªç”±åƒåŠ ï¼ŒåŒæ„å†æŠ•å¹£</li>
          <li>è«‹éµå®ˆæ´»å‹•è¦å‰‡ï¼Œè‹¥ å¤šåˆ®ã€ä½œå¼Š åŠç²çç„¡æ•ˆ</li>
          <li>å°ä¸»æ“æœ‰è®Šæ›´æˆ–æå‰çµæŸæ´»å‹•æ¬Šåˆ©</li>
        </ul>
        <img src="image/logo.png" class="scratch-logo">
      </div>
    </header>
    <main class="scratch-wrap">
      <div class="grid-container">
        <button v-for="(num, index) in gridNumbers"
                :key="index"
                class="grid-button"
                :class="{
                  'is-scratched': revealedNumbers[index] !== null,
                  'is-redeemed': redeemedNumbers[index]
                }"
                @click="openScratchCard(index)"
                :disabled="revealedNumbers[index] !== null">
          {{ revealedNumbers[index] !== null ? revealedNumbers[index] : '' }}
          <span v-if="redeemedNumbers[index]" class="redeemed-mark"></span>
        </button>
      </div>
      
      <!-- æ·»åŠ æ¸¬è©¦æŒ‰éˆ• -->
      <div class="test-buttons">
        <button @click="testRedeem">æ¸¬è©¦å…Œæ›</button>
        <button @click="resetRedeem">é‡ç½®å…Œæ›ç‹€æ…‹</button>
      </div>
    </main>

    <div v-if="showModal" class="modal">
      <div class="modal-content">
        <div class="scratch-card">
          <div class="scratch-card-cover-container">
            <canvas class="scratch-card-canvas" width="200" height="200"></canvas>
            <img class="scratch-card-canvas-render hidden" alt="">
            <div class="scratch-card-cover shine">
              <svg class="scratch-card-cover-background" viewBox="0 0 200 200">
                <path d="M 0,0 L 200,0 L 200,200 L 0,200 Z" />
              </svg>
            </div>
          </div>
          <div class="scratch-card-number">
            <canvas ref="numberCanvas" width="200" height="200"></canvas>
          </div>
        </div>

        <p class="scratch-card-text">ğŸ åˆ®å‡ºæ‚¨çš„å¹¸é‹æ•¸å­—!</p>
        <button class="close-button" @click="closeModal">{{ isScratched ? 'é—œé–‰' : 'æ›ä¸€å€‹' }}</button>
        <button v-if="isScratched && !redeemedNumbers[currentIndex]" 
                class="redeem-button" 
                @click="redeemNumber">
          å…Œæ›çå“
        </button>
      </div>
    </div>

    <svg width="0" height="0">
      <filter id="remove-black" color-interpolation-filters="sRGB">
        <feColorMatrix type="matrix" values="1 0 0 0 0
                            0 1 0 0 0
                            0 0 1 0 0
                            -1 -1 -1 0 1" result="black-pixels" />
        <feComposite in="SourceGraphic" in2="black-pixels" operator="out" />
      </filter>
      <filter id="noise">
        <feTurbulence baseFrequency="0.5"></feTurbulence>
      </filter>
    </svg>
  </div>

  <script>
    const { createApp, ref } = Vue

    const app = createApp({
      setup() {
        const isSafari = ref(/^((?!chrome|android).)*safari/i.test(navigator.userAgent));
        let previousUrl = null;

        const showModal = ref(false);
        const currentIndex = ref(null);
        const currentNumber = ref(null);
        const gridNumbers = ref(Array(80).fill(null).map((_, i) => i + 1).sort(() => Math.random() - 0.5));
        const revealedNumbers = ref(Array(80).fill(null));
        const redeemedNumbers = ref(Array(80).fill(false)); // æ–°å¢å…Œæ›ç‹€æ…‹è¿½è¹¤
        const numberCanvas = ref(null);
        const isScratched = ref(false);

        // æ–°å¢å…Œæ›åŠŸèƒ½
        const redeemNumber = () => {
          if (currentIndex.value !== null) {
            redeemedNumbers.value[currentIndex.value] = true;
            closeModal();
          }
        };

        // æ¸¬è©¦ç”¨å‡½æ•¸
        const testRedeem = () => {
          // éš¨æ©Ÿé¸æ“‡ä¸€å€‹å·²åˆ®é–‹çš„æ•¸å­—é€²è¡Œå…Œæ›
          const scratchedIndices = revealedNumbers.value
            .map((num, index) => num !== null ? index : -1)
            .filter(index => index !== -1);
          
          if (scratchedIndices.length > 0) {
            const randomIndex = scratchedIndices[Math.floor(Math.random() * scratchedIndices.length)];
            redeemedNumbers.value[randomIndex] = true;
          }
        };

        const resetRedeem = () => {
          redeemedNumbers.value = Array(80).fill(false);
        };

        const scratchCardCover = ref(null);
        const scratchCardCanvasRender = ref(null);
        const scratchCardCoverContainer = ref(null);
        const scratchCardText = ref(null);
        const scratchCardImage = ref(null);
        const canvas = ref(null);
        const context = ref(null);
        let isPointerDown = false;
        let positionX;
        let positionY;
        let clearDetectionTimeout = null;

        const drawNumber = () => {
          const ctx = numberCanvas.value.getContext('2d');
          ctx.clearRect(0, 0, 200, 200);
          ctx.font = 'bold 72px Inter';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#000';
          ctx.fillText(currentNumber.value, 100, 100);
        };

        const openScratchCard = (index) => {
          currentIndex.value = index;
          currentNumber.value = gridNumbers.value[index];
          showModal.value = true;
          isScratched.value = false;
          setTimeout(() => {
            initCanvas();
            drawNumber();
          }, 100);
        };

        const closeModal = () => {
          showModal.value = false;
          if(canvas.value) {
            context.value.clearRect(0, 0, canvas.value.width, canvas.value.height);
          }
          scratchCardCover.value?.classList.add('shine');
          scratchCardCoverContainer.value?.classList.remove('clear', 'hidden');
          scratchCardImage.value?.classList.remove('animate');
          isScratched.value = false;
        };

        const initCanvas = () => {
          canvas.value = document.querySelector('canvas');
          context.value = canvas.value.getContext('2d');
          scratchCardCover.value = document.querySelector('.scratch-card-cover');
          scratchCardCanvasRender.value = document.querySelector('.scratch-card-canvas-render');
          scratchCardCoverContainer.value = document.querySelector('.scratch-card-cover-container');
          scratchCardText.value = document.querySelector('.scratch-card-text');
          scratchCardImage.value = document.querySelector('.scratch-card-number');
          numberCanvas.value = document.querySelector('.scratch-card-number canvas');

          const devicePixelRatio = window.devicePixelRatio || 1;
          const canvasWidth = canvas.value.offsetWidth * devicePixelRatio;
          const canvasHeight = canvas.value.offsetHeight * devicePixelRatio;

          canvas.value.width = canvasWidth;
          canvas.value.height = canvasHeight;

          context.value.scale(devicePixelRatio, devicePixelRatio);

          if (isSafari.value) {
            canvas.value.classList.add('hidden');
          }

          setupEventListeners();
          
          // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨åˆ°scratch-card-number
          scratchCardImage.value.addEventListener('click', () => {
            isScratched.value = true;
            scratchCardCoverContainer.value.classList.add('clear', 'hidden');
            scratchCardText.value.textContent = 'ğŸ‰ æ­å–œåˆ®å‡º ' + currentNumber.value + ' !';
            scratchCardImage.value.classList.add('animate');
            revealedNumbers.value[currentIndex.value] = currentNumber.value;
            confetti({
              particleCount: 100,
              spread: 90,
              origin: {
                y: (scratchCardText.value.getBoundingClientRect().bottom + 60) / window.innerHeight,
              },
            });
          });
        };

        const setupEventListeners = () => {
          canvas.value.addEventListener('pointerdown', handlePointerDown);
        };

        const handlePointerDown = (e) => {
          scratchCardCover.value.classList.remove('shine');
          ({ x: positionX, y: positionY } = getPosition(e));
          clearTimeout(clearDetectionTimeout);

          canvas.value.addEventListener('pointermove', plot);

          window.addEventListener('pointerup', (e) => {
            canvas.value.removeEventListener('pointermove', plot);
            clearDetectionTimeout = setTimeout(() => {
              checkBlackFillPercentage();
            }, 500);
          }, { once: true });
        };

        const checkBlackFillPercentage = () => {
          const imageData = context.value.getImageData(0, 0, canvas.value.width, canvas.value.height);
          const pixelData = imageData.data;

          let blackPixelCount = 0;

          for (let i = 0; i < pixelData.length; i += 4) {
            const red = pixelData[i];
            const green = pixelData[i + 1];
            const blue = pixelData[i + 2];
            const alpha = pixelData[i + 3];

            if (red === 0 && green === 0 && blue === 0 && alpha === 255) {
              blackPixelCount++;
            }
          }

          const blackFillPercentage = blackPixelCount * 100 / (canvas.value.width * canvas.value.height);

          if (blackFillPercentage >= 1) { // åˆ®é–‹å°±è§¸ç™¼
            isScratched.value = true;
            scratchCardCoverContainer.value.classList.add('clear');
            confetti({
              particleCount: 100,
              spread: 90,
              origin: {
                y: (scratchCardText.value.getBoundingClientRect().bottom + 60) / window.innerHeight,
              },
            });
            scratchCardText.value.textContent = 'ğŸ‰ æ­å–œåˆ®å‡º ' + currentNumber.value + ' !';
            scratchCardImage.value.classList.add('animate');
            scratchCardCoverContainer.value.addEventListener('transitionend', () => {
              scratchCardCoverContainer.value.classList.add('hidden');
              revealedNumbers.value[currentIndex.value] = currentNumber.value;
              // ç§»é™¤äº‹ä»¶ç›£è½å™¨,é˜²æ­¢ç¹¼çºŒåˆ®
              canvas.value.removeEventListener('pointerdown', handlePointerDown);
              canvas.value.removeEventListener('pointermove', plot);
            }, { once: true });
          }
        };

        const getPosition = ({ clientX, clientY }) => {
          const { left, top } = canvas.value.getBoundingClientRect();
          return {
            x: clientX - left,
            y: clientY - top,
          };
        };

        const plotLine = (context, x1, y1, x2, y2) => {
          var diffX = Math.abs(x2 - x1);
          var diffY = Math.abs(y2 - y1);
          var dist = Math.sqrt(diffX * diffX + diffY * diffY);
          var step = dist / 50;
          var i = 0;
          var t;
          var x;
          var y;

          while (i < dist) {
            t = Math.min(1, i / dist);

            x = x1 + (x2 - x1) * t;
            y = y1 + (y2 - y1) * t;

            context.beginPath();
            context.arc(x, y, 16, 0, Math.PI * 2);
            context.fill();

            i += step;
          }
        };

        const setImageFromCanvas = () => {
          canvas.value.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            previousUrl = scratchCardCanvasRender.value.src;
            scratchCardCanvasRender.value.src = url;
            if (!previousUrl) {
              scratchCardCanvasRender.value.classList.remove('hidden');
            } else {
              URL.revokeObjectURL(previousUrl);
            }
            previousUrl = url;
          });
        };

        let setImageTimeout = null;

        const plot = (e) => {
          const { x, y } = getPosition(e);
          plotLine(context.value, positionX, positionY, x, y);
          positionX = x;
          positionY = y;
          if (isSafari.value) {
            clearTimeout(setImageTimeout);

            setImageTimeout = setTimeout(() => {
              setImageFromCanvas();
            }, 5);
          }
        };

        return {
          isSafari,
          showModal,
          currentNumber,
          currentIndex,
          gridNumbers,
          revealedNumbers,
          redeemedNumbers,
          openScratchCard,
          closeModal,
          numberCanvas,
          isScratched,
          redeemNumber,
          testRedeem,
          resetRedeem
        }
      }
    })

    app.mount('#app')
  </script>
</body>

</html>