<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <link rel="stylesheet" href="css/styleB.css">
</head>

<body>
  <div id="app">
    <div class="aside">
      <div class="aside-container">
        <div class="aside-infor">
          <div class="aside-number">
            <span>{{ totalNumbers - revealedNumbers.filter(n => n !== null).length }}</span>/<span>{{ totalNumbers }}</span>
          </div>
          <div class="aside-datetime">{{ currentDateTime }}</div>
        </div>
        <div class="aside-rule">
          <ul class="scratch-rule">
            <li>æ­¤æ´»å‹•ç‚ºé¡å¤–åŠ ç¢¼ï¼Œéæ©Ÿå°å…§è²©å”®å•†å“</li>
            <li>ç¬¦åˆè³‡æ ¼å¯è‡ªç”±åƒåŠ ï¼ŒåŒæ„å†æŠ•å¹£</li>
            <li>è«‹éµå®ˆæ´»å‹•è¦å‰‡ï¼Œè‹¥ å¤šåˆ®ã€ä½œå¼Š åŠç²çç„¡æ•ˆ</li>
            <li>å°ä¸»æ“æœ‰è®Šæ›´æˆ–æå‰çµæŸæ´»å‹•æ¬Šåˆ©</li>
          </ul>
        </div>
      </div>
    </div>
    <main class="scratch-wrap">
      <div class="grid-container">
        <button v-for="(num, index) in gridNumbers"
                :key="index"
                class="grid-button"
                :class="{
                  'is-scratched': revealedNumbers[index] !== null,
                  'is-redeemed': redeemedNumbers[index]
                }"
                @click="openScratchCard(index)"
                :disabled="revealedNumbers[index] !== null">
          {{ revealedNumbers[index] !== null ? revealedNumbers[index] : '' }}
          <span v-if="redeemedNumbers[index]" class="redeemed-mark"></span>
        </button>
      </div>
    </main>

    <div v-if="showModal" class="modal">
      <div class="modal-content">
        <div class="scratch-card">
          <div class="scratch-card-cover-container">
            <canvas class="scratch-card-canvas" width="200" height="200"></canvas>
            <img class="hidden scratch-card-canvas-render" alt="">
            <div class="scratch-card-cover shine">
              <svg class="scratch-card-cover-background" viewBox="0 0 200 200">
                <path d="M 0,0 L 200,0 L 200,200 L 0,200 Z" />
              </svg>
            </div>
          </div>
          <div class="scratch-card-number">
            <canvas ref="numberCanvas" width="200" height="200"></canvas>
          </div>
        </div>

        <p class="scratch-card-text">ğŸ åˆ®å‡ºæ‚¨çš„å¹¸é‹æ•¸å­—!</p>
        <button class="close-button" @click="closeModal" :disabled="isScratching || !canClose" v-if="isScratched">é—œé–‰</button>
        <button class="close-button" @click="closeModal" v-else>æ›ä¸€å€‹</button>
      </div>
    </div>

    <svg width="0" height="0">
      <filter id="remove-black" color-interpolation-filters="sRGB">
        <feColorMatrix type="matrix" values="1 0 0 0 0
                            0 1 0 0 0
                            0 0 1 0 0
                            -1 -1 -1 0 1" result="black-pixels" />
        <feComposite in="SourceGraphic" in2="black-pixels" operator="out" />
      </filter>
      <filter id="noise">
        <feTurbulence baseFrequency="0.5"></feTurbulence>
      </filter>
    </svg>
  </div>

  <script>
    const { createApp, ref } = Vue

    const app = createApp({
      setup() {
        const totalNumbers = 72; // ç¸½æ•¸é‡è¨­å®š

        const isSafari = ref(/^((?!chrome|android).)*safari/i.test(navigator.userAgent));
        let previousUrl = null;

        const showModal = ref(false);
        const currentIndex = ref(null);
        const currentNumber = ref(null);
        const gridNumbers = ref(Array(totalNumbers).fill(null).map((_, i) => i + 1).sort(() => Math.random() - 0.5));
        const revealedNumbers = ref(Array(totalNumbers).fill(null));
        const redeemedNumbers = ref(Array(totalNumbers).fill(false));
        const numberCanvas = ref(null);
        const isScratched = ref(false);
        const isScratching = ref(false);
        const currentDateTime = ref('');
        const canClose = ref(false); // æ–°å¢æ§åˆ¶é—œé–‰æŒ‰éˆ•çš„ç‹€æ…‹

        // æ›´æ–°ç•¶å‰æ™‚é–“
        const updateDateTime = () => {
          const now = new Date();
          const year = now.getFullYear();
          const month = String(now.getMonth() + 1).padStart(2, '0');
          const day = String(now.getDate()).padStart(2, '0');
          const hours = String(now.getHours()).padStart(2, '0');
          const minutes = String(now.getMinutes()).padStart(2, '0');
          const seconds = String(now.getSeconds()).padStart(2, '0');
          currentDateTime.value = `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
        };

        // åˆå§‹åŒ–æ™‚æ›´æ–°æ™‚é–“ä¸¦æ¯ç§’æ›´æ–°
        updateDateTime();
        setInterval(updateDateTime, 1000);

        // æ–°å¢å…Œæ›åŠŸèƒ½
        const redeemNumber = () => {
          if (currentIndex.value !== null) {
            redeemedNumbers.value[currentIndex.value] = true;
            closeModal();
          }
        };

        // æ¸¬è©¦ç”¨å‡½æ•¸
        const testRedeem = () => {
          // éš¨æ©Ÿé¸æ“‡ä¸€å€‹å·²åˆ®é–‹çš„æ•¸å­—é€²è¡Œå…Œæ›
          const scratchedIndices = revealedNumbers.value
            .map((num, index) => num !== null ? index : -1)
            .filter(index => index !== -1);

          if (scratchedIndices.length > 0) {
            const randomIndex = scratchedIndices[Math.floor(Math.random() * scratchedIndices.length)];
            redeemedNumbers.value[randomIndex] = true;
          }
        };

        const resetRedeem = () => {
          redeemedNumbers.value = Array(totalNumbers).fill(false);
        };

        const scratchCardCover = ref(null);
        const scratchCardCanvasRender = ref(null);
        const scratchCardCoverContainer = ref(null);
        const scratchCardText = ref(null);
        const scratchCardImage = ref(null);
        const canvas = ref(null);
        const context = ref(null);
        let isPointerDown = false;
        let positionX;
        let positionY;
        let clearDetectionTimeout = null;

        const drawNumber = () => {
          const ctx = numberCanvas.value.getContext('2d');
          ctx.clearRect(0, 0, 200, 200);

          // è¨­ç½®å­—é«”æ¨£å¼
          const fonts = ['Inter', 'Arial', 'Verdana'];
          const randomFont = fonts[Math.floor(Math.random() * fonts.length)];
          const fontSize = Math.floor(Math.random() * 20 + 60); // 60-80ä¹‹é–“
          ctx.font = `bold ${fontSize}px ${randomFont}`;

          // è¨ˆç®—æ–‡å­—å¯¬åº¦ä»¥ç¢ºä¿ä¸æœƒè¢«åˆ‡åˆ°
          const textWidth = ctx.measureText(currentNumber.value).width;

          // æ ¹æ“šæ–‡å­—å¯¬åº¦è¨ˆç®—å®‰å…¨çš„xç¯„åœ
          const minX = textWidth/2 + 10;
          const maxX = 200 - textWidth/2 - 10;
          const x = Math.random() * (maxX - minX) + minX;

          // æ ¹æ“šå­—é«”å¤§å°è¨ˆç®—å®‰å…¨çš„yç¯„åœ
          const minY = fontSize/2 + 10;
          const maxY = 200 - fontSize/2 - 10;
          const y = Math.random() * (maxY - minY) + minY;

          // éš¨æ©Ÿæ—‹è½‰è§’åº¦(æ¸›å°‘æ—‹è½‰ç¯„åœä»¥é¿å…åˆ‡åˆ°)
          const rotation = (Math.random() - 0.5) * 0.3;

          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rotation);

          // éš¨æ©Ÿå‚¾æ–œ(æ¸›å°‘å‚¾æ–œç¯„åœä»¥é¿å…åˆ‡åˆ°)
          ctx.transform(1, Math.random() * 0.2 - 0.1, Math.random() * 0.2 - 0.1, 1, 0, 0);

          // è¨­ç½®æ–‡å­—æ¨£å¼
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = '#282834';

          // æ·»åŠ é™°å½±æ•ˆæœ
          ctx.shadowColor = 'rgba(0,0,0,0.1)';
          ctx.shadowBlur = 5;
          ctx.shadowOffsetX = 2;
          ctx.shadowOffsetY = 2;

          // ç¹ªè£½æ•¸å­—
          ctx.fillText(currentNumber.value, 0, 0);

          // æ·»åŠ é›œè¨Šæ•ˆæœ
          for(let i = 0; i < 500; i++) {
            const noiseX = Math.random() * 200;
            const noiseY = Math.random() * 200;
            const size = Math.random() * 1.5;
            const opacity = Math.random() * 0.3;

            ctx.fillStyle = `rgba(0,0,0,${opacity})`;
            ctx.beginPath();
            ctx.arc(noiseX - x, noiseY - y, size, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
        };

        const openScratchCard = (index) => {
          currentIndex.value = index;
          currentNumber.value = gridNumbers.value[index];
          showModal.value = true;
          isScratched.value = false;
          isScratching.value = false;
          canClose.value = false; // é‡ç½®é—œé–‰æŒ‰éˆ•ç‹€æ…‹
          setTimeout(() => {
            initCanvas();
            drawNumber();
          }, 100);
        };

        const closeModal = () => {
          if (!isScratching.value && (canClose.value || !isScratched.value)) {
            showModal.value = false;
            if(canvas.value) {
              context.value.clearRect(0, 0, canvas.value.width, canvas.value.height);
            }
            scratchCardCover.value?.classList.add('shine');
            scratchCardCoverContainer.value?.classList.remove('clear', 'hidden');
            scratchCardImage.value?.classList.remove('animate');
            isScratched.value = false;
            isScratching.value = false;
            canClose.value = false; // é‡ç½®é—œé–‰æŒ‰éˆ•ç‹€æ…‹
          }
        };

        const initCanvas = () => {
          canvas.value = document.querySelector('canvas');
          context.value = canvas.value.getContext('2d');
          scratchCardCover.value = document.querySelector('.scratch-card-cover');
          scratchCardCanvasRender.value = document.querySelector('.scratch-card-canvas-render');
          scratchCardCoverContainer.value = document.querySelector('.scratch-card-cover-container');
          scratchCardText.value = document.querySelector('.scratch-card-text');
          scratchCardImage.value = document.querySelector('.scratch-card-number');
          numberCanvas.value = document.querySelector('.scratch-card-number canvas');

          const devicePixelRatio = window.devicePixelRatio || 1;
          const canvasWidth = canvas.value.offsetWidth * devicePixelRatio;
          const canvasHeight = canvas.value.offsetHeight * devicePixelRatio;

          canvas.value.width = canvasWidth;
          canvas.value.height = canvasHeight;

          context.value.scale(devicePixelRatio, devicePixelRatio);

          if (isSafari.value) {
            canvas.value.classList.add('hidden');
          }

          setupEventListeners();

          // æ·»åŠ é»æ“Šäº‹ä»¶ç›£è½å™¨åˆ°scratch-card-number
          scratchCardImage.value.addEventListener('click', () => {
            isScratched.value = true;
            scratchCardCoverContainer.value.classList.add('clear', 'hidden');
            scratchCardText.value.textContent = 'ğŸ‰ æ­å–œåˆ®å‡º ' + currentNumber.value + ' !';
            scratchCardImage.value.classList.add('animate');
            revealedNumbers.value[currentIndex.value] = currentNumber.value;
            confetti({
              particleCount: 100,
              spread: 90,
              zIndex: 9999,
              origin: {
                y: (scratchCardText.value.getBoundingClientRect().bottom + 60) / window.innerHeight,
              },
            });
            // å»¶é²1.5ç§’å¾Œæ‰å…è¨±é—œé–‰
            setTimeout(() => {
              canClose.value = true;
            }, 1500);
          });
        };

        const setupEventListeners = () => {
          canvas.value.addEventListener('pointerdown', handlePointerDown);
        };

        const handlePointerDown = (e) => {
          isScratching.value = true;
          isScratched.value = true; // ç•¶é–‹å§‹åˆ®çš„æ™‚å€™å°±è¨­ç½®ç‚ºtrue
          scratchCardCover.value.classList.remove('shine');
          ({ x: positionX, y: positionY } = getPosition(e));
          clearTimeout(clearDetectionTimeout);

          canvas.value.addEventListener('pointermove', plot);

          window.addEventListener('pointerup', (e) => {
            canvas.value.removeEventListener('pointermove', plot);
            clearTimeout(clearDetectionTimeout);
            clearDetectionTimeout = setTimeout(() => {
              checkBlackFillPercentage();
              isScratching.value = false;
            }, 500);
          }, { once: true });
        };

        const checkBlackFillPercentage = () => {
          const imageData = context.value.getImageData(0, 0, canvas.value.width, canvas.value.height);
          const pixelData = imageData.data;

          let blackPixelCount = 0;

          for (let i = 0; i < pixelData.length; i += 4) {
            const red = pixelData[i];
            const green = pixelData[i + 1];
            const blue = pixelData[i + 2];
            const alpha = pixelData[i + 3];

            if (red === 0 && green === 0 && blue === 0 && alpha === 255) {
              blackPixelCount++;
            }
          }

          const blackFillPercentage = blackPixelCount * 100 / (canvas.value.width * canvas.value.height);

          if (blackFillPercentage >= 1) { // åˆ®é–‹å°±è§¸ç™¼
            scratchCardCoverContainer.value.classList.add('clear');
            confetti({
              particleCount: 100,
              spread: 90,
              origin: {
                y: (scratchCardText.value.getBoundingClientRect().bottom + 60) / window.innerHeight,
              },
            });
            scratchCardText.value.textContent = 'ğŸ‰ æ­å–œåˆ®å‡º ' + currentNumber.value + ' !';
            scratchCardImage.value.classList.add('animate');
            scratchCardCoverContainer.value.addEventListener('transitionend', () => {
              scratchCardCoverContainer.value.classList.add('hidden');
              revealedNumbers.value[currentIndex.value] = currentNumber.value;
              // ç§»é™¤äº‹ä»¶ç›£è½å™¨,é˜²æ­¢ç¹¼çºŒåˆ®
              canvas.value.removeEventListener('pointerdown', handlePointerDown);
              canvas.value.removeEventListener('pointermove', plot);
              // å»¶é²1.5ç§’å¾Œæ‰å…è¨±é—œé–‰
              setTimeout(() => {
                canClose.value = true;
              }, 1500);
            }, { once: true });
          }
        };

        const getPosition = ({ clientX, clientY }) => {
          const { left, top } = canvas.value.getBoundingClientRect();
          return {
            x: clientX - left,
            y: clientY - top,
          };
        };

        const plotLine = (context, x1, y1, x2, y2) => {
          var diffX = Math.abs(x2 - x1);
          var diffY = Math.abs(y2 - y1);
          var dist = Math.sqrt(diffX * diffX + diffY * diffY);
          var step = dist / 50;
          var i = 0;
          var t;
          var x;
          var y;

          while (i < dist) {
            t = Math.min(1, i / dist);

            x = x1 + (x2 - x1) * t;
            y = y1 + (y2 - y1) * t;

            context.beginPath();
            context.arc(x, y, 16, 0, Math.PI * 2);
            context.fill();

            i += step;
          }
        };

        const setImageFromCanvas = () => {
          canvas.value.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            previousUrl = scratchCardCanvasRender.value.src;
            scratchCardCanvasRender.value.src = url;
            if (!previousUrl) {
              scratchCardCanvasRender.value.classList.remove('hidden');
            } else {
              URL.revokeObjectURL(previousUrl);
            }
            previousUrl = url;
          });
        };

        let setImageTimeout = null;

        const plot = (e) => {
          const { x, y } = getPosition(e);
          plotLine(context.value, positionX, positionY, x, y);
          positionX = x;
          positionY = y;
          if (isSafari.value) {
            clearTimeout(setImageTimeout);

            setImageTimeout = setTimeout(() => {
              setImageFromCanvas();
            }, 5);
          }
        };

        return {
          isSafari,
          showModal,
          currentNumber,
          currentIndex,
          gridNumbers,
          revealedNumbers,
          redeemedNumbers,
          openScratchCard,
          closeModal,
          numberCanvas,
          isScratched,
          isScratching,
          redeemNumber,
          testRedeem,
          resetRedeem,
          currentDateTime,
          totalNumbers,
          canClose // å°å‡ºcanCloseç‹€æ…‹
        }
      }
    })

    app.mount('#app')
  </script>
</body>

</html>